---
layout: post
title:  "Binary Search Lower/Upper bound with BOJ problems"
excerpt: "classification: Binary Search"


categories:
  - Blog
tags:
  - [Blog, jekyll, Github, Git]

 
date: 2021-02-12
last_modified_at: 2021-02-12
---
* * *
#### usage of BS Lower/Upper bound:
##### In an ascending array, number of elements what I'm looking for can be calculated through index.
#
##### el : 1 1 2 2 2 2 3 5 5 
##### idx: 0 1 2 3 4 5 6 7 8
###### number of element 2 is idx 6- idx 2- 4.
###### This method is alike counting numbers in range [2,6): 6-2= 4.
#
#
###### Since both upper bound and lower bound should be found individually, 
###### two separate binary searching loop should be implemented.
#
#
#
##### There are several elements that should always be considered when implementing BS loop.
#

> #### 1: When should the loop be breaked?
> #### 2. When loop is breaked, where is the answer located?
#

#### consideration) 1. loop should be breaked when there are no ways left to narrow the gap.
###### The concept of binary search is narrowing down the range(by half) where answer can be located
###### By simply knowing the process of BS, it can be misunderstood that the gap can be always narrowed to 1.
###### But there is a problem: binary searched array idxs are integer: so middle of 0 and 1 is not 0.5; it is 0. (0+1)//2= 1
###### so when gap is 2 and lo heads to mid, binary loop should be breaked and answer should be found by checking remaing 2 elements individually.
###### When gap is 2 and lo heads to mid+1, binary loop should be breaked automatically !
#
#### consideration) 2. When loop is breaked, where is the answer located?
###### If the goal doesn't exists, the idx that is pointed should be manually am

#
#
### 2143 sum of two arrays(G3)
##### URL https://www.acmicpc.net/problem/2143
##### difficulty: __Gold 3__
#
#
> ### Problem description
> #### Find number of combinations that sums up to t, with sub array of A and sub array of B
> 
> > #### input(s)
> > ##### n: size of array A
> > ##### elements of A
> > ##### m: size of array B
> > ##### elements of B
>
> > #### print out(s):
> > ##### number of combinations that sums up to t, (t= sub arr a+ sub arr b)

* * *


#
<img width="374" alt=".png">


#### code) 


    t= int(input())
    n= int(input())
    a= [0]+ [*map(int, input().split())]
    m= int(input())
    b= [0]+ [*map(int, input().split())]

    def getSubSeq(leng, seq, L):
      s=0
      for i in range(1, leng+1):
          s+=seq[i]
          tmp =s
          for j in range(i):
              tmp-=seq[j]
              L.append(tmp)

    A=[]
    B=[]
    getSubSeq(n, a, A)
    getSubSeq(m, b, B)
    A.sort()
    B.sort()

    lastB=len(B)-1
    def TP(ths):
      global lastB

      # lower bound
      lo= 0
      hi= lastB
      left= 0
      
      while lo<hi: # 같은애들 중 가장 왼쪽, 같은애없으면 큰거중 가장 왼쪽 찾는 게 목표
          mid= (lo+hi)//2
          if B[mid]>=ths:
              hi= mid
          else:
              lo=mid+1
      if B[lo]<ths: # 그런애들이 없었어서 아닌 애를 가리키고 있음
          left=lo+1
      else:
          left=lo


      # upper bound
      lo= 0
      hi= lastB
      right= 0
      
      while lo<hi: # 큰애들 중 가장 왼쪽껄 찾는 게 목표
          mid= (lo+hi)//2
          if B[mid]>ths:
              hi= mid
          else:
              lo=mid+1
      if B[lo]<=ths: # 큰애들이 없었어서 아닌 애를 가리키고 있음
          right=lo+1
      else:
          right=lo

      return right-left
      


    ans=0
    prv= [1e6+1, 0] # num, ans
    for el in A:
        if el==prv[0]:
            ans+=prv[1]
        else:
            prv= [el, TP(t-el)]
            ans+=prv[1]
    print(ans)
