---
layout: post
title:  "scheduling"
excerpt: "reviews"


categories:
  - Blog
tags:
  - [Blog, jekyll, Github, Git]

 
date: 2021-07-26
last_modified_at: 2021-07-26
---



시스템 성능 지표들
평균 응답 시간 (mean response time)
사용자 지향적, 예) interactive systems
처리량 (throughput)
시스템 지향적, 예) batch systems
자원 활용도 (resource utilization)
공평성(fairness), 예) FIFO
실행 대기 방지
무기한 대기 방지
예측 가능성(predictability)
적절한 시간안에 응답을 보장하는가
자원 할당의 공정성 보장
단위시간당 처리량 최대화
적절한 반환시간 보장
예측 가능성 보장
오버헤드 최소화
자원 사용의 균형 유지
반환시간과 자원의 활용 간에 균형 유지
실행 대기 방지
우선순위
서비스 사용 기회 확대
서비스 수 감소 방지



스케줄링 기준 (Criteria)
스케줄링 기법이 고려하는 항목들
프로세스(process)의 특성
I/O-bounded process : I/O burst > CPU burst
Compute-bounded process : CPU burst > I/O burst
시스템 특성
Batch system or interactive system
프로세스의 긴급성(urgency)
Hard- or soft- real time, non-real time systems
프로세스 우선순위 (priority)
프로세스 총 실행 시간 (total service time)


Long-term Scheduling
Job scheduling
시스템에 제출 할 (Kernel에 등록 할) 작업(Job) 결정
발생 빈도는 적다.
Admission scheduling, High-level scheduling
다중프로그래밍 정도(degree) 조절
시스템 내에 프로세스 수 조절
I/O-bounded 와 compute-bounded 프로세스들을 잘 섞어서 선택해야 함
시분할 시스템에서는 모든 작업을 시스템에 등록
Long-term scheduling이 상대적으로 덜 중요하다
 
Mid-term Scheduling
메모리 할당 결정 (memory allocation)
Intermediate-level scheduling
Swapping (swap-in/swap-out)
 
Short-term Scheduling
Process scheduling
Low-level scheduling
프로세서(processor)를 할당할 프로세스(process)를 결정
Processor scheduler, dispatcher
가장 빈번하게 발생
Interrupt, block (I/O), time-out, Etc.
매우 빨라야 함
average CPU burst = 100ms 
scheduling decision = 10ms
10 x (100+10) = 9% 
of the CPU is being used simply for scheduling





스케줄링 정책 (Policy)
선점 vs 비선점
Preemptive scheduling, Non-preemptive scheduling
우선순위
Priority





Priority
프로세스의 중요도
Static priority (정적 우선순위)
프로세스 생성시 결정된 priority가 유지 됨
구현이 쉽고, overhead가 적음
시스템 환경 변화에 대한 대응이 어려움
Dynamic priority (동적 우선순위)
프로세스의 상태 변화에 따라 priority 변경
구현이 복잡, priority 재계산 overhead가 큼
시스템 환경 변화에 유연한 대응 가능





MLQ -> MLFQ

MLQ 단점

Q1
Q2
Q3

위 큐 무조건 먼저

Q2 ~ 배치받은애들은 Q1 항상 다른 애들이 있으면 얘네는 실행되지 않는다
Starvation 

MLFQ



MLFQ?
큐간의 프로세스 이동이 가능하다!

기준: 위나 아래로 이동하는 기준
2. 프로세스가 들어갈 큐를 결정하는 기준 등

Ex) 



SJF  

설명기준: 같은시간에 들어올때

0     100

1      2, 2


SJF 비선점/ 선점 PSJF (STCF)

비선점 기준 : 어떤일이?
Convey effect 

장점: 평균 반환시간이 단축된다 !!!!



https://www.netinbag.com/ko/internet/what-is-cpu-virtualization.html



    cpu 가상화 : 하드웨어의 도움을 받아 운영체제가 시스템에 매우 많은 수의 가상 cpu가 존재하는 듯한 환상을 만들어 낸 것.
    CPU 가상화를 멀티 태스킹 또는 하이퍼 스레딩과 혼동해서는 안됩니다. ??


멀티태스킹은 운영체제가 CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법이다. 
멀티 태스킹은 한 번에 둘 이상의 응용 프로그램을 실행하는 작업입니다. 모든 최신 운영 체제에서는 단일 CPU에서이 작업을 수행 할 수 있지만 기술적으로 특정 시점에 하나의 응용 프로그램 만 처리됩니다. 하이퍼 스레딩은 호환되는 CPU가 동시에 두 가지 작업을 수행하는 방식으로 특수하게 작성된 응용 프로그램을 실행할 수있는 곳입니다.





     현대의 운영체제는 시분할 방식을 기본으로 사용하기 때문에 프로세스가 여러 상태를 오가며 실행된다.
    준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케쥴러가 담당한다. 

    문맥: 메모리의 코드, 데이터, 스택, 범용 레지스터 내용, PC, 환경변수, 열려있는 파일의 식별자

    운영체제 커널은 문맥전환을 사용해서 멀티태스킹을 구현하고 있다.

    문맥은 선점된 프로세스를 다시 시작하기 위해서 필요로 하는 상태이다. 

    스케쥴했다: 커널이 실행할 새 프로세스를 선택했다. 

    문맥전환: 저장, 복원, 제어전달

    문맥전환은 커널이 사용자를 대신해서 시스템콜을 실행하고 있을 때, 인터럽트의 결과로 발생할 수 있다.
    타이머 인터럽타 1ms~ 10ms


        엑세스 속도와 용량의 관계
      1. (CPU)레지스터 - 가장 빠름
      2. (CPU)캐시 메모리
      3. (내부)메인 메모리
      4. (외부)하드디스크 - 가장 느림, 가장 용량이 큼

         CPU는 입출력 관리자에게 작업 지시를 내리고 다른일을 하다가 완료신호를 받으면 하던 일을 중단하고 옮겨진 데이터를 처리한다.
    이때 입출력 관리자가 CPU에 보내는 완료 신호를 인터럽트라고 한다



        17. 스케쥴링:
    CPU 스케쥴러응 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 하며, CPU 스케쥴링은 CPU 스케쥴러가 하는 모든 작업을 가리킨다.

    스케쥴링 목적:
    공평성, 효율성, 안정성(즁요프로세스 먼저, 보호), 확장성(프로세스 증가), 반응시간 보장, 무한 연기 방지



    concurrency 동시성: time sharing

    폰 노이만 구조'의 특징은 CPU가 어느 한 순간에 딱 하나의 연산(계산)만 수행할 수 있다는 점이다. 전자공학이 눈부시게 발전해옴에 따라 CPU의 용량과 처리속도가 늘어나고, 사람이 인식할 수 없을 정도로 빠르게 계산을 할 수 있게 되면서, 사람을 살짝 속이는 시분할 방식의 멀티태스킹을 사용하게 되면서 컴퓨터가 동시에 여러가지 일을 하는 것 같은 착시가 생긴 것 뿐이다. 이 멀티태스킹은 한편으로 컨텍스트 스위치(Context Switch)라는 성능 저하를 가져오지만, 너무 빨라진  CPU 덕분에 무시할 수 있을 정도가 되었다.



    선점형 비선점형

    선점형: 프로세스가 CPU를 독점할 수 없어 시분할 시스템에 적합하지만 문맥교환 : 시분할 방식 스케쥴러
    비선점형: 기다리는 프로세스가 많아 처리율이 떨어진다 : 일괄 처리 방식 스케쥴러

    HRN 스케쥴링: 우선순위 = (대기 시간 + CPU 사용시간) / CPU 사용시간

    아사현상 해결

    [스케쥴링들 평가]

    1. FCFS : convoy effect 일어난다.(뒤의 작업이 자연됨), 비선점형이라 CPU idle 시분할 시스템에서 프로세스의 상태를 따지는 거다
        공정o 반환 good 응답 x

    2. SJF : 사용자와 상호작용이 없는 옛날엔 전체 연산 개수 안았는데, 현대 프로세스는 프로그램 종료 시간 파악하기 어렵다. 추청못함
        공정x : starvation
        한계가 있지만 aging으로: 예시로 세살만 먹으면 비키도록
        SRT(STCF) 선점형 SJF : 남은 시간 주기적으로 계산, 여전히 아사


    3 HRN: '여전히' 공정성 위배 ** (대기 시간 + CPU 사용시간) / CPU 사용시간

    * 4. RR: 우선순위가 적용되지 않은 가장 단순한 선점형 스케쥴링 타임슬라이스 정하는 게 중요하다
      convoy, starv 없음
      응답시간이 좋다
      반환시간 기준에서는 성능이 나쁘다
      유형의 절충

  멀티 스레드 환경에서의 필요성

  멀티 스레드 환경에서 하나의 스레드가 CPU를 독점하는 상황과 다른 스레드가 실행되지 못하고 무한정 기다리는 '기아' 현상을 막기 위해 각 스레드에 적절한 CPU 사용 시간을 부여하여 모든 스레드가 순환적으로 실행되도록 하는 것


    유닉스 운체는 10~200 밀리초 사이에 조정할 수 있도록 한다 MLFQ 사용하기 때문

    5. 우선순위 스케쥴링: 선점 비선점 모두 적용가능, 고정, 변동이 있다
      공정성 위배: 아사현상

    6. MLQ: 아사현상

    * 7. MLFQ: 아사현상 해결: 큐간이 프로세스 이동이 가능한 것, 오늘날의 CPU 스케쥴링을 위해 일반적으로 사용하는 방식

    규칙 5가지:
    우선순위별로
    같으면 rr
    처음 들어가면 1번큐
    배정 시간 소진하면 우선순위 감소시킴
    일정 주기 지나면 최상위큐로 옮김


    8. lottery scheduling: 더 자주 수행돼야하는 애한테 당첨 기회를 많이주는 것
    추첨권 양도: 클라이언트 서버 환경에서 특히 유용하다!
    사진

    구현이 단순하다

    9. 보폭 stride 스케쥴링
    얼마나 CPU 사용했는지 추적

    10. 리눅스 CFS 장점: 효율성과 확장성

    스케쥴러이 효율성이 전체 시스템의 성능에 매우 중요한 성능을 갖는다
    스케쥴러가 전체 데이터 센어 CPU 사용량의 5%, 스케쥴링의 오버헤드를 최대한 줄이는 게 스케쥴러의 목표이다

    vruntime : 보폭스케쥴링
    최소 타임 슬라이스. 


멀티쓰레딩 혹은 멀티프로세스를 할 때 스케쥴링 기법에 대해 설명하시오

Windows계열을 게임서버로 쓰는 이유로는.. 클라이언트가 거의 대부분 Windows기반으로 개발하니 같은 조건이라면 서버도 Windows로 하는 게 일관성도 있고 편하겠지요.
주로. 윈도우 nt 기반

왼도우는 우선순위 + RR 적절히 혼용


게임 서버와 게임 클라이언트는 그 목적과 역할이 정 반대이다.

게임 클라이언트는 화려한 그래픽과 무거운 용량을 자랑한다. 게임 클라이언트는 사용자에게 극대화된 수준의 그래픽 연출을 보여주기 위해 컴퓨터 하드웨어의 성능을 극한으로 남김 없이 사용해야 한다. 그렇기 때문에, 제아무리 좋은 컴퓨터를 사용해도 쿨링팬이 굉음을 내며 돌아갈 수밖에 없다.

게임 클라이언트는 최대한 화려한 것을 사용자에게 보여줘야 한다. 하지만 게임 서버는 아무리 보여줘 봤자 '랙' 아니면 '서버 다운'뿐이다. 즉 잘 만들어진 게임 서버일수록 그 존재를 드러내지 않아야 한다. 아마도 궁극적인 경지에 오른 게임 서버는 그 자체를 아무도 느끼지 못하는 수준이 아닐까?

앞 편에서 언급했듯이, 게임 서버는 화면에 보여주는 것 없이 뇌 역할을 한다. 그러다 보니 게임 서버의 실행 모습은 클라이언트와 달리 무척 밋밋하게 생겼다. 프리 서버를 써본 독자들은 알겠지만 (웬만하면 그 프리섭이라는 것은 즉시 갖다 버리길 권장한다. 매우 위험한 물건이다.) 프리서버는 화면에 보여주는 것이 무척 밋밋한 프로그램이다.


게임 서버는 'Daemon'이라고 불리는 상태로 작동한다. 

게임 서버가 구동되는 운영체제는 우리가 일반적으로 쓰고 있는 윈도(Windows)가 아니다. 윈도 서버(Windows Server)나 리눅스(Linux)라고 불리는 특수 목적의 서버 운영체제에서 게임 서버를 실행하는 경우가 일반적이다.




스케쥴했다: 커널이 실행할 새 프로세스를 선택했다. 


문맥: 메모리의 코드, 데이터, 스택, 범용 레지스터 내용, PC, 환경변수, 열려있는 파일의 식별자

   문맥전환: 저장, 복원, 제어전달



￼





1. FCFS : 오는 시간 순서대로 비선점형 큐

단점 : convoy effect. (응답시간)
장점: “””””””” 공정 “”””””””””      반환성 좋음

* convoy effect : 뒤의 작업이 자연됨


앞 에께 1년짜리면 뒤에 애들이 당하는 게 convoy :  (( 영원히 안되는 게 아님 )) 

대기 시간이 길어져  < CPU 사용 효율 > 이 감소하는 현상 ??
대기 반환 시간 계산할때
AWT가 길어지니까 얘를 기준으로 CPU 사용 효율을 따지 때문

지금도 쓰인다 어디에? 큐 

시간도 nlogn 차이나니까

공정함을 보장해야하는 프로그램은 얘를 쓸 수밖에 없겠다.





2. SJF : 빨리끝나는 순서별로 (비선점)

사용자와 상호작용x

이 당시에는 전체 연산 개수 알 수 있었음


현대 프로세스 : 사용자와 상호작용 o

프로그램 종료 시간 파악하기 어렵다. 추청못함


* 단점 : “”””””””””” 공정 x “”””””””””””  : 기아현상 이 있음
* < CPU 사용 효율 > 이 감소하지는 않는다!


기아현상의 정의: 너무오랜 세월?   (( 영원히 안 될 수 있음 ))
우선순위가 밀림

		

공정 <-> 기아현상 starvation

Convoy 해결하기 위해 SJF 등장했는데 starvation이 생겼다


STCF 선점형 SJF: 시작시간 다를때



3. HRN : (대기 시간 + CPU 사용시간) / CPU 사용시간 : 선점 새치기 안됨
Highest Response ratio Next)


‘여전히' 공정성 위배.    “ 공정성 “ ??? !










반환시간 : 모든작업을 완료하는 시간 아래에서부턴 반환시간 ‘만’ 느림
반환시간 기준에서는 성능이 나쁘다





4. RR: 대표적인 선점형 스케튤린 타임슬라이스 

convoy, starv 없음
응답시간이 좋다


유형의 절충

얘는 “원형큐”다! 타임 슬라이스 잘라노면 맨 뒤로 가니까





멀티스레드에서 유용하니까. 타임슬라이스 이용해서 기아 막아주니까 time quantum
RR 을 쓰는 이유 : 오는 순서대로, 타임 슬라이스를 사용

  멀티 스레드 환경에서의 필요성 멀티 스레드와 직결되는 첫 스케쥴링

  멀티 스레드 환경에서 하나의 스레드가 CPU를 독점하는 상황과 다른 스레드가 실행되지 못하고 무한정 기다리는 '기아' 현상을 막기 위해 각 스레드에 적절한 CPU 사용 시간을 부여하여 모든 스레드가 순환적으로 실행되도록 하는 것




5. 우선순위 스케쥴링: 선점 비선점 모두 적용가능, 고정, 변동이 있다
      공정성 위배: starvation 타임슬라이스가 없다!


  6. MLQ: starvation 여러 큐 사용하는 방식

위에 있는 큐 순서대로 니까


위에는 순서를 바꾸는 규칙이




7. MLFQ 규칙 5가지


  0. 처음 들어가면 1번큐
 0.5   배정 시간 소진하면 우선순위 감소시킴



1. 우선순위별로 위에 있는 큐 순서대로 니까
2. 우선순위가 큐가 같다면 ?  같으면 rr
3. 일정 주기 지나면 최상위큐로 옮김 






8. Lottery 100 더 자주 수행돼야하는 애한테 당첨 기회를 많이주는 것

두개의 프로세스 1~70 / 71~100

7: 3

45 

추첨 스케쥴링은 타임 슬라이스가 끝날 때마다 확률 기반으로 달성한다


구현단순



9 보폭 stride 스케쥴링
얼마나 CPU 사용했는지 추적

￼






10. 리눅스 CFS vruntime 80% 


 장점: 효율성과 확장성




11. 윈도우는 우선순위 + RR 적절히 혼용

윈도 서버(Windows Server)









HRN


RR

MLFQ

Lotter

Stride

리눅스 CFS


윈도 의 스케쥴링



* MLQ, MLFQ 는 RR 기반이다 ! 
낮은 큐는 FCFS
각 큐는 독립된 스케쥴링 법칙을 갖고 있다

기본적으로 얘네 둘의 디폴트는 RR이다